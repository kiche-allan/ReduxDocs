// In React, a callback is a function that is passed as a parameter to another component or function, allowing the receiving component or function to invoke that callback at a later time. Callbacks are commonly used in React to handle asynchronous operations, events, or data updates.

// Here's an example of how callbacks can be used in React:

import React from 'react'

function Button(props) {
    return (
        <button onClick={props.onClick}>
            {props.text}

        </button>
    );
}

function App(){
    const handleClick = () => {
        console.log('Button clicked');
    };

    return (
        <div>
            <h1>Callback example</h1>
            <Button onClick = {handleClick} text = 'Click me!'/>
        </div>
    )
}

export default App;


// In the code above, we have two components: Button and App. The Button component receives a prop called onClick, which expects a callback function. When the button is clicked, React will invoke the callback function provided as onClick.

// In the App component, we define a function called handleClick which logs a message to the console when invoked. We then pass handleClick as the callback to the onClick prop of the Button component.

// When the button is clicked, React triggers the onClick event and calls the handleClick function, resulting in the message "Button clicked!" being logged to the console.

// Callbacks are useful for handling user interactions, fetching data from APIs, updating state, and communicating between components in React applications. They allow you to pass behavior as a function from parent components to child components, enabling a more flexible and modular design.

// 1.2.1. Actions
// Every change to state starts with an action (figure 1.1). An action is a JavaScript object
// describing an event in your application. They’re typically generated by either a user
// interaction or by a server event, such as an HTTP response.
// 1.2.2. Dispatcher
// All data flow in a Flux application is funneled through a single dispatcher. The
// dispatcher itself has little functionality, because its purpose is to receive all actions and
// send them to each store that has been registered. Every action will be sent to every
// store.
// 1.2.3. Stores
// Each store manages the state of one domain within an application. In an ecommerce
// site, you may expect to find a shopping cart store and a product store, for example.
// Once a store is registered with the dispatcher, it begins to receive actions. When it
// receives an action type that it cares about, the store updates accordingly. Once a change
// to the store is made, an event is broadcast to let the views know to update using the new
// state

// Reducers are functions responsible for updating your state in response to actions.
// They’re simple functions that take your current state and an action as arguments, and
// return the next state

// In Redux, application state is stored in a single object. The store has a few main roles,
// which follow:
// Hold application state.
// Provide a way to access state.
// Provide a way to specify updates to state. The store requires an action be dispatched
// to modify state.
// Allow other entities to subscribe to updates (React components in this case). View
// bindings provided by react­redux will allow you to receive updates from the store
// and respond to them in your components.

// 1.4. WHY SHOULD I USE REDUX?
// By this point, you’ve been exposed to many of the Redux talking points. If you have to
// pitch your boss on Redux by the time you finish the first chapter, let’s consolidate those
// ideas into a highlight reel. In short, Redux is a small, easy­to­learn state management
// library that results in a highly predictable, testable, and debuggable application.
// 1.4.1. Predictability
// The biggest selling point for Redux is the sanity it provides to applications juggling
// complex state. The Redux architecture offers a straightforward way to conceptualize
// and manage state, one action at a time. Regardless of application size, actions within
// the unidirectional data flow result in predictable changes to a single store.
// 1.4.2. Developer experience
// Predictability enables world­class debugging tools. Hot­loading and time­travel
// debugging provide developers with wildly faster development cycles, whether building
// new features or hunting down bugs. Your boss will like that you’re a happier developer,
// but she’ll love that you’re a faster one.
// 1.4.3. Testability
// The Redux implementation code you’ll write is primarily functions, many of them pure.
// Each piece of the puzzle can be broken out and unit­tested in isolation with ease.
// Official documentation uses Jest and Enzyme, but whichever JavaScript testing
// libraries your organization prefers will do the trick