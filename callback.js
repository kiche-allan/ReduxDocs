// In React, a callback is a function that is passed as a parameter to another component or function, allowing the receiving component or function to invoke that callback at a later time. Callbacks are commonly used in React to handle asynchronous operations, events, or data updates.

// Here's an example of how callbacks can be used in React:

import React from 'react'

function Button(props) {
    return (
        <button onClick={props.onClick}>
            {props.text}

        </button>
    );
}

function App(){
    const handleClick = () => {
        console.log('Button clicked');
    };

    return (
        <div>
            <h1>Callback example</h1>
            <Button onClick = {handleClick} text = 'Click me!'/>
        </div>
    )
}

export default App;


// In the code above, we have two components: Button and App. The Button component receives a prop called onClick, which expects a callback function. When the button is clicked, React will invoke the callback function provided as onClick.

// In the App component, we define a function called handleClick which logs a message to the console when invoked. We then pass handleClick as the callback to the onClick prop of the Button component.

// When the button is clicked, React triggers the onClick event and calls the handleClick function, resulting in the message "Button clicked!" being logged to the console.

// Callbacks are useful for handling user interactions, fetching data from APIs, updating state, and communicating between components in React applications. They allow you to pass behavior as a function from parent components to child components, enabling a more flexible and modular design.

// 1.2.1. Actions
// Every change to state starts with an action (figure 1.1). An action is a JavaScript object
// describing an event in your application. They’re typically generated by either a user
// interaction or by a server event, such as an HTTP response.
// 1.2.2. Dispatcher
// All data flow in a Flux application is funneled through a single dispatcher. The
// dispatcher itself has little functionality, because its purpose is to receive all actions and
// send them to each store that has been registered. Every action will be sent to every
// store.
// 1.2.3. Stores
// Each store manages the state of one domain within an application. In an ecommerce
// site, you may expect to find a shopping cart store and a product store, for example.
// Once a store is registered with the dispatcher, it begins to receive actions. When it
// receives an action type that it cares about, the store updates accordingly. Once a change
// to the store is made, an event is broadcast to let the views know to update using the new
// state

// Reducers are functions responsible for updating your state in response to actions.
// They’re simple functions that take your current state and an action as arguments, and
// return the next state

// In Redux, application state is stored in a single object. The store has a few main roles,
// which follow:
// Hold application state.
// Provide a way to access state.
// Provide a way to specify updates to state. The store requires an action be dispatched
// to modify state.
// Allow other entities to subscribe to updates (React components in this case). View
// bindings provided by react­redux will allow you to receive updates from the store
// and respond to them in your components.